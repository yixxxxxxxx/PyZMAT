from ase import Atoms
from ase.io import read, write
from ase.geometry import *
from ase.constraints import *
from ase.optimize import BFGS
from ase.optimize.bfgslinesearch import BFGSLineSearch
from ase.units import *

from mace.calculators import mace_off

import time

from scipy.optimize import minimize
import numpy as np

import copy
import ast

import re



class Constraints:
    """
    A class to store constraints for bonds, angles, and dihedrals.
    Each entry can be an integer (the index) or a tuple (index, value).
    If value is not provided (or is None), the current Z-matrix value will be used.
    """
    def __init__(self, bonds=None, angles=None, dihedrals=None):
        self.bonds = self._validate_dof_list(bonds if bonds is not None else [], "bonds")
        self.angles = self._validate_dof_list(angles if angles is not None else [], "angles")
        self.dihedrals = self._validate_dof_list(dihedrals if dihedrals is not None else [], "dihedrals")

    @staticmethod
    def _validate_dof_list(value, name):
        if not isinstance(value, list):
            raise TypeError(f"{name} must be a list of integers or (integer, value) tuples")
        validated = []
        for item in value:
            if isinstance(item, int):
                validated.append((item, None))
            elif isinstance(item, tuple):
                if len(item) != 2:
                    raise ValueError(f"Each tuple in {name} must have exactly 2 elements: (index, value)")
                index, val = item
                if not isinstance(index, int):
                    raise TypeError(f"In {name}, the index must be an integer")
                if val is not None and not isinstance(val, (int, float)):
                    raise TypeError(f"In {name}, the value must be a number or None")
                validated.append((index, val))
            else:
                raise TypeError(f"Each element in {name} must be an integer or a (integer, value) tuple")
        if name == "angles":
            for index, _ in validated:
                if index < 2:
                    raise ValueError("All indices in the angle list must be at least 2")
        if name == "dihedrals":
            for index, _ in validated:
                if index < 3:
                    raise ValueError("All indices in the dihedral list must be at least 3")
        return validated

    def __repr__(self):
        return f"Constraints(bonds={self.bonds}, angles={self.angles}, dihedrals={self.dihedrals})"
        


class ParseUtils:

    @staticmethod
    def get_zmat_def(out_file):
        zmat_def = []
        with open(out_file, 'r') as file:
            content = file.read()
            data = ast.literal_eval(content)
            for row in data:
                zmat_row = tuple([int(i) - 1 if i != '' else None for i in row])
                zmat_def.append(zmat_row)
        return zmat_def

    @staticmethod
    def parse_zmat(zmat_str):
        """
        Parse a Zmatrix file generated by Gaussian_to_CP_input_V5.py and convert it to the zmat_conn format.
        
        The file is parsed using the full labels (e.g. C1, H2, O3) so that connectivity can be determined correctly.
        At the final step, the trailing digits are removed from the atom labels in the resulting zmat_conn.
        
        Returns:
          zmat_conn : list of tuples (atom_symbol, bond_ref, angle_ref, dihedral_ref)
                      where the atom_symbol no longer contains trailing digits.
        """
        if not isinstance(zmat_str, str):
            raise TypeError("zmat_str must be a string.")
    
        lines = zmat_str.strip().splitlines()
        if not lines:
            raise ValueError("The provided Z-matrix string is empty.")
        if lines and lines[0].strip().lower().startswith("z-matrix"):
            lines = lines[1:]
        
        label_mapping = {}
        zmat_conn = []
        
        # Build the connectivity using full labels (with trailing numbers)
        for i, line in enumerate(lines):
            tokens = line.split()
            if not tokens:
                continue
            # Use the full label (e.g. "C1") for connectivity logic.
            atom_label = tokens[0]
            label_mapping[atom_label] = i
            conn_row = []
            for j in range(1, 4):
                if j < len(tokens):
                    label = tokens[j]
                    conn_index = label_mapping.get(label, None)
                    if conn_index is None:
                        raise ValueError(f"Reference label '{label}' in line {i+1} not defined previously.")
                    conn_row.append(conn_index)
                else:
                    conn_row.append(None)
            zmat_conn.append((atom_label,) + tuple(conn_row))
        
        # Final step: remove trailing digits from the atom symbols
        def strip_label(label):
            return re.sub(r'\d+$', '', label)
        
        final_zmat_conn = [(strip_label(atom), b, a, d) for atom, b, a, d in zmat_conn]
        return final_zmat_conn
        
    @staticmethod
    def parse_gaussian_input_old(com_file):
        """
        Parses a Gaussian input file containing a Z-matrix with variable definitions.
        - com_file: Gaussian input file path
        
        Returns:
        - zmat: a list of lists, where each row is [atom_symbol, bond_length, bond_angle, dihedral_angle]
                (with None for missing entries)
        - zmat_conn: a list of tuples, where each tuple is (bond_ref, angle_ref, dihedral_ref)
                (with None for missing connectivity references)
        """
        with open(com_file, "r") as f:
            lines = f.readlines()
                
        zmatrix_lines = []
        variables_dict = {}
        constants_dict = {}
            
        # Flags to control reading of different sections.
        reading_zmatrix = False
        reading_vars = False
        reading_consts = False
            
        for line in lines:
            line = line.strip()
            if not line:
                continue
            # Start reading geometry after the line with "0 1"
            if not reading_zmatrix and line.startswith("0 "):
                reading_zmatrix = True
                continue
            # End of Z-matrix block when "variables:" is encountered.
            if reading_zmatrix and line.lower().startswith("variables:"):
                reading_zmatrix = False
                reading_vars = True
                continue
            # Switch to reading constants when "constants:" is encountered.
            if reading_vars and line.lower().startswith("constants:"):
                reading_vars = False
                reading_consts = True
                continue
                
            if reading_zmatrix:
                zmatrix_lines.append(line)
            elif reading_vars:
                parts = line.split()
                if len(parts) >= 2:
                    key = parts[0]
                    try:
                        value = float(parts[1])
                        variables_dict[key] = value
                    except ValueError:
                        pass  # skip if conversion fails
            elif reading_consts:
                parts = line.split()
                if len(parts) >= 2:
                    key = parts[0]
                    try:
                        value = float(parts[1])
                        constants_dict[key] = value
                    except ValueError:
                        pass
        
        # Combine variable dictionaries (constants can override if needed)
        param_dict = {}
        param_dict.update(variables_dict)
        param_dict.update(constants_dict)
            
        zmat = []
        zmat_conn = []
            
        # Parse each Z-matrix line.
        for i, line in enumerate(zmatrix_lines):
            tokens = line.split()
            if not tokens:
                continue
            # Remove any trailing digits from the atom symbol (e.g., "S1" -> "S")
            m = re.match(r"([A-Za-z]+)", tokens[0])
            atom = m.group(1) if m else tokens[0]
                
            # Initialize default values.
            bond_val = None
            angle_val = None
            dihedral_val = None
            conn = (atom, None, None, None)
                
            if len(tokens) == 1:
                # First atom: no connectivity.
                pass
            elif len(tokens) == 3:
                # Second atom: format: Atom  ref  bond_param
                bond_ref = int(tokens[1])
                bond_param = tokens[2]
                bond_val = param_dict.get(bond_param)
                conn = (atom, bond_ref - 1, None, None)
            elif len(tokens) == 5:
                # Third atom: format: Atom  bond_ref  bond_param  angle_ref  angle_param
                bond_ref = int(tokens[1])
                bond_param = tokens[2]
                angle_ref = int(tokens[3])
                angle_param = tokens[4]
                bond_val = param_dict.get(bond_param)
                angle_val = param_dict.get(angle_param)
                conn = (atom, bond_ref - 1, angle_ref - 1, None)
            elif len(tokens) == 7:
                # Fourth and subsequent atoms: 
                # Format: Atom  bond_ref  bond_param  angle_ref  angle_param  dihedral_ref  dihedral_param
                bond_ref = int(tokens[1])
                bond_param = tokens[2]
                angle_ref = int(tokens[3])
                angle_param = tokens[4]
                dihedral_ref = int(tokens[5])
                dihedral_param = tokens[6]
                bond_val = param_dict.get(bond_param)
                angle_val = param_dict.get(angle_param)
                dihedral_val = param_dict.get(dihedral_param)
                conn = (atom, bond_ref - 1, angle_ref - 1, dihedral_ref - 1)
            else:
                print("Warning: Unexpected format in line:", line)
                
            zmat.append([atom, bond_val, angle_val, dihedral_val])
            zmat_conn.append(conn)
            
        return zmat, zmat_conn

    @staticmethod
    def parse_gaussian_input(com_file):
        """
        Parses a Gaussian input file containing a Z-matrix with variable definitions.
        
        The file is assumed to contain:
          - A Z-matrix section (starting after the line "0 1")
          - A "Variables:" block
          - A "Constants:" block
        
        The "Variables:" and "Constants:" blocks provide parameter values, with constants
        used to build a Constraints object.
        
        Returns:
          - zmat: a list of lists, where each row is [atom_symbol, bond_length, bond_angle, dihedral_angle]
                  (with None for missing entries)
          - zmat_conn: a list of tuples, where each tuple is (atom_symbol, bond_ref, angle_ref, dihedral_ref)
                  (with connectivity indices converted to 0-indexing)
          - constraints: a Constraints object built from the "Constants:" block (keys like "bnd4", "ang5", "dih6")
        """
        with open(com_file, "r") as f:
            lines = f.readlines()
                    
        zmatrix_lines = []
        variables_dict = {}
        constants_dict = {}
                
        # Flags to control reading of different sections.
        reading_zmatrix = False
        reading_vars = False
        reading_consts = False
                
        for line in lines:
            line = line.strip()
            if not line:
                continue
            # Start reading geometry after the line with "0 1"
            if not reading_zmatrix and line.startswith("0 "):
                reading_zmatrix = True
                continue
            # End of Z-matrix block when "variables:" is encountered.
            if reading_zmatrix and line.lower().startswith("variables:"):
                reading_zmatrix = False
                reading_vars = True
                continue
            # Switch to reading constants when "constants:" is encountered.
            if reading_vars and line.lower().startswith("constants:"):
                reading_vars = False
                reading_consts = True
                continue
                    
            if reading_zmatrix:
                zmatrix_lines.append(line)
            elif reading_vars:
                parts = line.split()
                if len(parts) >= 2:
                    key = parts[0]
                    try:
                        value = float(parts[1])
                        variables_dict[key] = value
                    except ValueError:
                        pass  # skip if conversion fails
            elif reading_consts:
                parts = line.split()
                if len(parts) >= 2:
                    key = parts[0]
                    try:
                        value = float(parts[1])
                        constants_dict[key] = value
                    except ValueError:
                        pass
            
        # Combine variable dictionaries (constants can override if needed) for parameter lookup.
        param_dict = {}
        param_dict.update(variables_dict)
        param_dict.update(constants_dict)
                
        zmat = []
        zmat_conn = []
                
        # Parse each Z-matrix line.
        for i, line in enumerate(zmatrix_lines):
            tokens = line.split()
            if not tokens:
                continue
            # Remove any trailing digits from the atom symbol (e.g., "S1" -> "S")
            m = re.match(r"([A-Za-z]+)", tokens[0])
            atom = m.group(1) if m else tokens[0]
                    
            # Initialize default values.
            bond_val = None
            angle_val = None
            dihedral_val = None
            conn = (atom, None, None, None)
                    
            if len(tokens) == 1:
                # First atom: no connectivity.
                pass
            elif len(tokens) == 3:
                # Second atom: format: Atom  ref  bond_param
                bond_ref = int(tokens[1])
                bond_param = tokens[2]
                bond_val = param_dict.get(bond_param)
                conn = (atom, bond_ref - 1, None, None)
            elif len(tokens) == 5:
                # Third atom: format: Atom  bond_ref  bond_param  angle_ref  angle_param
                bond_ref = int(tokens[1])
                bond_param = tokens[2]
                angle_ref = int(tokens[3])
                angle_param = tokens[4]
                bond_val = param_dict.get(bond_param)
                angle_val = param_dict.get(angle_param)
                conn = (atom, bond_ref - 1, angle_ref - 1, None)
            elif len(tokens) == 7:
                # Fourth and subsequent atoms: 
                # Format: Atom  bond_ref  bond_param  angle_ref  angle_param  dihedral_ref  dihedral_param
                bond_ref = int(tokens[1])
                bond_param = tokens[2]
                angle_ref = int(tokens[3])
                angle_param = tokens[4]
                dihedral_ref = int(tokens[5])
                dihedral_param = tokens[6]
                bond_val = param_dict.get(bond_param)
                angle_val = param_dict.get(angle_param)
                dihedral_val = param_dict.get(dihedral_param)
                conn = (atom, bond_ref - 1, angle_ref - 1, dihedral_ref - 1)
            else:
                print("Warning: Unexpected format in line:", line)
                    
            zmat.append([atom, bond_val, angle_val, dihedral_val])
            zmat_conn.append(conn)
        
        # Build a Constraints object from the constants_dict.
        bonds_constraints = []
        angles_constraints = []
        dihedrals_constraints = []
        for key, value in constants_dict.items():
            key_lower = key.lower()
            try:
                if key_lower.startswith("bnd"):
                    # e.g., "bnd4" means atom index 3 (4-1)
                    index = int(key_lower[3:]) - 1
                    bonds_constraints.append((index, value))
                elif key_lower.startswith("ang"):
                    index = int(key_lower[3:]) - 1
                    angles_constraints.append((index, value))
                elif key_lower.startswith("dih"):
                    index = int(key_lower[3:]) - 1
                    dihedrals_constraints.append((index, value))
            except ValueError:
                continue
        
        constraints = Constraints(bonds=bonds_constraints,
                                  angles=angles_constraints,
                                  dihedrals=dihedrals_constraints)
                
        return zmat, zmat_conn, constraints
        
    
    @staticmethod
    def parse_gaussian_fchk(filename, zmat_conn):
        """
        Reads a Gaussian formatted FCHK file and returns an ASE Atoms object, a list of internal forces,
        and the total energy. Atomic symbols are taken from the provided zmat_conn connectivity list.
        
        The FCHK file is assumed to contain sections with headers like:
        
          Current cartesian coordinates              R   N=          <num>
          Internal Forces                            R   N=          <num>
          Total Energy                               R     <energy_value>
        
        Parameters:
          filename (str): Path to the FCHK file.
          zmat_conn (list): List of connectivity tuples of the form 
                            (symbol, bond_ref, angle_ref, dihedral_ref).
                            The first element of each tuple is used as the atomic symbol.
                            
        Returns:
          atoms (ase.Atoms): ASE Atoms object with positions from the FCHK file.
          forces (list of float): List of internal force values extracted from the file.
          energy (float): The total energy extracted from the file.
        """
        with open(filename, "r") as f:
            lines = f.readlines()
        
        coords = []
        forces = []
        energy = None
        
        reading_coords = False
        reading_forces = False
        total_coord_numbers = None
        total_force_numbers = None
    
        # First, search for the Total Energy line.
        for line in lines:
            if line.strip().startswith("Total Energy"):
                # Expect a line like:
                # "Total Energy                               R     -4.204536819762593E+02"
                tokens = line.split()
                if len(tokens) >= 4:
                    try:
                        energy = float(tokens[3])
                        energy = energy * Ha
                    except ValueError:
                        raise ValueError("Could not convert the energy value to float.")
                break
    
        # Now parse coordinates and forces.
        for line in lines:
            # Look for the coordinates header.
            if "Current cartesian coordinates" in line:
                parts = line.split("N=")
                if len(parts) > 1:
                    try:
                        total_coord_numbers = int(parts[1].strip())
                    except ValueError:
                        pass
                reading_coords = True
                continue
    
            # Look for the forces header.
            if "Internal Forces" in line:
                parts = line.split("N=")
                if len(parts) > 1:
                    try:
                        total_force_numbers = int(parts[1].strip())
                    except ValueError:
                        pass
                reading_forces = True
                continue
    
            # If reading coordinates, parse numbers.
            if reading_coords:
                if not line.strip():
                    if total_coord_numbers is not None and len(coords) >= total_coord_numbers:
                        reading_coords = False
                    continue
                tokens = line.split()
                for token in tokens:
                    try:
                        coords.append(float(token))
                    except ValueError:
                        pass
                if total_coord_numbers is not None and len(coords) >= total_coord_numbers:
                    reading_coords = False
    
            # If reading forces, parse numbers.
            if reading_forces:
                if not line.strip():
                    if total_force_numbers is not None and len(forces) >= total_force_numbers:
                        reading_forces = False
                    continue
                tokens = line.split()
                for token in tokens:
                    try:
                        forces.append(float(token))
                    except ValueError:
                        pass
                if total_force_numbers is not None and len(forces) >= total_force_numbers:
                    reading_forces = False
    
        if total_coord_numbers is None:
            raise ValueError("Could not determine the total number of coordinate values (N=?) from the header.")
        if len(coords) < total_coord_numbers:
            raise ValueError(f"Not enough coordinates found: expected {total_coord_numbers}, got {len(coords)}")
        
        # Reshape coordinates into an (num_atoms, 3) array.
        positions = np.array(coords[:total_coord_numbers]).reshape(-1, 3)
        positions = positions * Bohr
        num_atoms = positions.shape[0]

        # Convert forces from Ha/Bohr and Ha/rad to eV/Ang and eV/deg
        forces = [row * (Ha / Bohr if i in (0, 1) or i % 3 == 0 else Ha * np.pi / 180)
          for i, row in enumerate(forces)]
        
        if len(zmat_conn) != num_atoms:
            raise ValueError(f"Number of atoms in FCHK ({num_atoms}) does not match length of zmat_conn ({len(zmat_conn)})")
        
        # Extract atomic symbols from zmat_conn.
        symbols = [entry[0] for entry in zmat_conn]
    
        atoms = Atoms(symbols = symbols, positions = positions)
        zmat = ZmatUtils.atoms_2_zmat(atoms, zmat_conn)
        
        return zmat, forces, energy


    @staticmethod
    def parse_gaussian_log(filename, check_calc = False):
        """
        Extracts the optimized Z-matrix structure, internal forces, and final energy 
        from a Gaussian log file. In this log file, the connectivity (Symbolic Z-matrix)
        section appears first, then a Variables/Constants block, and then an Optimized
        Parameters block that provides updated internal coordinate values.
        
        The connectivity section is assumed to have a layout similar to:
        
           Symbolic Z-matrix:
            Charge =  0 Multiplicity = 1
            S1
            C1                   1    cs2
            C1                   2    cc3      1    ccs3
            C1                   3    cc4      2    ccc4     1    dih4     0
            ...
        
        The function parses this block to produce:
          - zmat_conn: list of tuples (symbol, bond_ref, angle_ref, dihedral_ref)
            (with indices converted from 1-indexed to 0-indexed; if a reference is missing, None is used).
          - param_names: a parallel list of tuples (bond_param, angle_param, dihedral_param)
            that indicate which parameter names are associated with each internal coordinate.
        
        Then the function reads the "Variables:" (and optionally "Constants:") block that immediately follows,
        and then the "Optimized Parameters" block, which looks like:
        
           ----------------------
           !      Name          Value   Derivative information (Atomic Units)     !
           ------------------------------------------------------------------------
           !       cs2         1.7501   -DE/DX =    0.0                           !
           !       cc3         1.3836   -DE/DX =   -0.0001                        !
           ...
        
        The optimized parameters override the values in the earlier Variables/Constants blocks.
        
        Finally, the function searches for the final SCF energy line, e.g.
                SCF Done:  E(RB3LYP) =  -1175.68824532     a.u. after    2 cycles
              
        The energy and forces are converted from Hartree to eV.
        
        Returns:
          zmat      : list of lists [symbol, bond_length, bond_angle, dihedral_angle] (optimized structure)
          zmat_conn : list of connectivity tuples (symbol, bond_ref, angle_ref, dihedral_ref)
          forces    : list of internal force values (in eV/Angstrom)
          energy    : final energy in eV
        """
        with open(filename, "r") as f:
            lines = f.readlines()
        
        # --- 1. Parse the Symbolic Z-matrix section ---
        zmat_conn = []
        param_names = []  # For each atom, store (bond_param, angle_param, dihedral_param)
        forces_list = []
        in_zmat = False
        skip_next_line = False
        for line in lines:
            if "Symbolic Z-matrix:" in line:
                in_zmat = True
                skip_next_line = True  # Skip the next line (Charge info)
                continue
            if in_zmat:
                if skip_next_line:
                    skip_next_line = False
                    continue
                line_strip = line.strip()
                # End the Z-matrix block if we hit "Variables:".
                if line_strip.lower().startswith("variables:"):
                    in_zmat = False
                    break
                if not line_strip:
                    continue
                tokens = line_strip.split()
                # Extract the atom symbol from the first token (e.g., "C1" -> "C")
                atom_symbol = re.match(r"([A-Za-z]+)", tokens[0]).group(1)
                if len(tokens) == 1:
                    # First atom: no connectivity.
                    zmat_conn.append((atom_symbol, None, None, None))
                    param_names.append((None, None, None))
                elif len(tokens) == 3:
                    # Format: "C1    1    cs2"
                    bond_ref = int(tokens[1]) - 1  # convert to 0-indexed
                    bond_param = tokens[2]
                    zmat_conn.append((atom_symbol, bond_ref, None, None))
                    param_names.append((bond_param, None, None))
                elif len(tokens) == 5:
                    # Format: "C1    2    cc3      1    ccs3"
                    bond_ref = int(tokens[1]) - 1
                    bond_param = tokens[2]
                    angle_ref = int(tokens[3]) - 1
                    angle_param = tokens[4]
                    zmat_conn.append((atom_symbol, bond_ref, angle_ref, None))
                    param_names.append((bond_param, angle_param, None))
                elif len(tokens) >= 7:
                    # Format: "C1    3    cc4      2    ccc4     1    dih4     0"
                    bond_ref = int(tokens[1]) - 1
                    bond_param = tokens[2]
                    angle_ref = int(tokens[3]) - 1
                    angle_param = tokens[4]
                    dihedral_ref = int(tokens[5]) - 1
                    dihedral_param = tokens[6]
                    # If there's an extra token (e.g. 0), we ignore it.
                    zmat_conn.append((atom_symbol, bond_ref, angle_ref, dihedral_ref))
                    param_names.append((bond_param, angle_param, dihedral_param))
                else:
                    # Unexpected format.
                    raise ValueError(f"Unexpected Z-matrix line format: {line_strip}")
        
        # --- 2. Parse Variables and Constants blocks ---
        var_dict = {}
        in_vars = False
        in_consts = False
        for line in lines:
            lstrip = line.strip()
            if lstrip.lower().startswith("variables:"):
                in_vars = True
                in_consts = False
                continue
            if lstrip.lower().startswith("constants:"):
                in_vars = False
                in_consts = True
                continue
            if in_vars or in_consts:
                if not lstrip:
                    continue
                parts = lstrip.split()
                if len(parts) >= 2:
                    key = parts[0]
                    try:
                        value = float(parts[1])
                        var_dict[key] = value
                    except ValueError:
                        continue
    
        # --- 3. Override with Optimized Parameters if available and collect forces ---
        # Look for a block that includes "Optimized Parameters"
        opt_params = {}
        opt_block = False
        for line in lines:
            if "Optimized Parameters" in line:
                opt_block = True
                continue
            if opt_block:
                # Skip header lines (lines with dashes or starting with "!")
                if re.match(r"^\s*-+", line) or re.match(r"^\s*!", line) is None:
                    # If line is not part of parameter listing, break.
                    continue
                # Alternatively, if line contains parameter info (it typically starts with "!")
                if line.strip().startswith("!"):
                    # Remove leading exclamation and spaces.
                    line_clean = line.strip("! \n")
                    # Expect format: Name Value ... e.g.
                    # "cs2         1.7501   -DE/DX =    0.0"
                    parts = line_clean.split()
                    if len(parts) >= 2:
                        key = parts[0]
                        try:
                            value = float(parts[1])
                            opt_params[key] = value
                            force = float(parts[4])
                            forces_list.append(force)
                        except ValueError:
                            continue
        # Override var_dict with any optimized parameters
        var_dict.update(opt_params)
        
        # --- 4. Build the full Z-matrix using connectivity and parameter names ---
        zmat = []
        # For each atom, assign internal coordinate values by looking up the parameter names.
        for i, (conn, params) in enumerate(zip(zmat_conn, param_names)):
            symbol = conn[0]
            if i == 0:
                zmat.append([symbol, None, None, None])
            elif i == 1:
                bond_param = params[0]
                bond_val = var_dict.get(bond_param, None) if bond_param else None
                zmat.append([symbol, bond_val, None, None])
            elif i == 2:
                bond_param, angle_param, _ = params
                bond_val = var_dict.get(bond_param, None) if bond_param else None
                angle_val = var_dict.get(angle_param, None) if angle_param else None
                zmat.append([symbol, bond_val, angle_val, None])
            else:
                bond_param, angle_param, dihedral_param = params
                bond_val = var_dict.get(bond_param, None) if bond_param else None
                angle_val = var_dict.get(angle_param, None) if angle_param else None
                dihedral_val = var_dict.get(dihedral_param, None) if dihedral_param else None
                zmat.append([symbol, bond_val, angle_val, dihedral_val])
        
        # --- 6. Parse Energy from "SCF Done:" line ---
        energy = None
        normal_termination = False
        for line in reversed(lines):
            if line.lstrip().startswith("Normal termination"):
                normal_termination = True
            if line.lstrip().startswith("SCF Done:"):
                # Typical line: "SCF Done:  E(RB3LYP) =  -1175.68824532     a.u. after    2 cycles"
                parts = line.split()
                try:
                    energy = float(parts[4]) * Ha
                except (IndexError, ValueError):
                    pass
                if energy is not None:
                    break
        if energy is None:
            raise ValueError("No 'SCF Done:' energy line found in the log file.")
        
        # --- 7. Unit Conversion ---
        # For internal forces, assume they are in Hartree/Angstrom.
        forces = [f * Ha for f in forces_list]

        if check_calc is True:

            if normal_termination is False:
                print('The calculation', filename, 'did not terminate normally.')

            return zmat, zmat_conn, forces, energy, normal_termination
            
        else:
            return zmat, zmat_conn, forces, energy

        
    
class ZmatUtils:
    """
    Contains functions concerning the conversion between cartesian and internal coordinates:
    kronecker_delta, atoms_2_zmat_init, atoms_2_zmat, get_zmat_def, parse_zmat, form_orthonormal_frame,
    zmat_2_atoms, get_B_matrix, get_single_fd_grad, get_fd_B_matrix, and print_xyz.
    """

    @staticmethod
    def kronecker_delta(i, j):
        """
        The Kronecker δ function returns 1 if its two inputs are equal and 0 otherwise.
        """
        if not isinstance(i, int) or not isinstance(j, int):
            raise TypeError("Inputs to kronecker_delta must be integers.")
        return 1 if i == j else 0

    @staticmethod
    def atoms_2_zmat_init(atoms, zmat_def):
        """
        Convert an ASE Atoms object (in Cartesian coordinates) into a Z-matrix representation.
        """
        if not isinstance(atoms, Atoms):
            raise TypeError("atoms must be an ASE Atoms object.")
        if not isinstance(zmat_def, list):
            raise TypeError("zmat_def must be a list of tuples.")
        for entry in zmat_def:
            if not (isinstance(entry, tuple) and len(entry) == 4):
                raise ValueError("Each element in zmat_def must be a tuple of four elements (atom_id, bond_id, angle_id, dihedral_id).")
        
        symbols = atoms.get_chemical_symbols()
        if max([t[0] for t in zmat_def]) >= len(atoms) or min([t[0] for t in zmat_def]) < 0:
            raise IndexError("Atom index in zmat_def is out of range of the atoms object.")
        zmat = []
        id_swap = {None: None}
    
        for i, (atom_id, bond_id, angle_id, dihedral_id) in enumerate(zmat_def):
            symbol = symbols[atom_id]
            bond_length = None if bond_id is None else atoms.get_distance(atom_id, bond_id)
            bond_angle = None if angle_id is None else atoms.get_angle(atom_id, bond_id, angle_id)
            dihedral_angle = None if dihedral_id is None else atoms.get_dihedral(atom_id, bond_id, angle_id, dihedral_id)
            zmat.append([symbol, bond_length, bond_angle, dihedral_angle])
            id_swap[atom_id] = i
    
        zmat_conn = []
        for (atom_id, bond_id, angle_id, dihedral_id) in zmat_def:
            symbol = symbols[atom_id]
            bond = id_swap[bond_id] if bond_id is not None else None
            angle = id_swap[angle_id] if angle_id is not None else None
            dihedral = id_swap[dihedral_id] if dihedral_id is not None else None
            zmat_conn.append((symbol, bond, angle, dihedral))
    
        return zmat, zmat_conn

    @staticmethod
    def atoms_2_zmat(atoms, zmat_conn):
        """
        Convert an ASE Atoms object to a Z-matrix, given the connectivities.
        """
        if not isinstance(atoms, Atoms):
            raise TypeError("atoms must be an ASE Atoms object.")
        if not isinstance(zmat_conn, list):
            raise TypeError("zmat_conn must be a list of tuples.")
        if len(zmat_conn) != len(atoms):
            raise ValueError("Length of zmat_conn must match the number of atoms in the atoms object.")
    
        symbols = atoms.get_chemical_symbols()
        zmat = []
        
        for i, conn in enumerate(zmat_conn):
            if not (isinstance(conn, tuple) and len(conn) == 4):
                raise ValueError("Each connectivity in zmat_conn must be a tuple of four elements (symbol, bond, angle, dihedral).")
            bond_ref = conn[1]
            angle_ref = conn[2]
            dihedral_ref = conn[3]
            bond_length = None if bond_ref is None else atoms.get_distance(i, bond_ref)
            bond_angle = None if angle_ref is None else atoms.get_angle(i, bond_ref, angle_ref)
            dihedral_angle = None if dihedral_ref is None else atoms.get_dihedral(i, bond_ref, angle_ref, dihedral_ref)
            zmat.append([symbols[i], bond_length, bond_angle, dihedral_angle])
    
        return zmat

    

    @staticmethod
    def form_orthonormal_frame(xyz, j, k, l):
        """
        Form a set of three orthonormal unit vectors and other useful quantities.
        """
        if not isinstance(xyz, (list, np.ndarray)):
            raise TypeError("xyz must be a list or numpy array of coordinates.")
        if max(j, k, l) >= len(xyz) or min(j, k, l) < 0:
            raise IndexError("Indices j, k, l must be within the range of xyz.")
    
        r_j = xyz[j]
        r_k = xyz[k]
        r_l = xyz[l]
    
        r_kj = r_j - r_k
        r_kl = r_l - r_k
    
        norm_rkj = np.linalg.norm(r_kj)
        norm_rkl = np.linalg.norm(r_kl)
        if norm_rkj == 0:
            raise ValueError("Cannot form orthonormal frame: reference atoms j and k coincide (zero bond length).")
        if norm_rkl == 0:
            raise ValueError("Cannot form orthonormal frame: reference atoms k and l coincide (zero bond length).")
    
        tvec1 = r_kj / norm_rkj
        tvec2 = r_kl / norm_rkl
    
        tcrp = np.cross(tvec1, tvec2)
        norm_tcrp = np.linalg.norm(tcrp)
        if norm_tcrp == 0:
            raise ValueError("Cannot form orthonormal frame: vectors tvec1 and tvec2 are parallel.")
        tcrp /= norm_tcrp
        ncrp = np.cross(tcrp, tvec1)
        
        return r_j, r_k, r_l, tvec1, tvec2, r_kj, r_kl, tcrp, ncrp

    @staticmethod
    def zmat_2_atoms(zmat, zmat_conn):
        """
        Convert a Z-matrix to an ASE Atoms object.
        """
        if not isinstance(zmat, list) or not all(isinstance(row, (list, tuple)) and len(row) >= 4 for row in zmat):
            raise TypeError("zmat must be a list of tuples/lists with at least 4 elements each.")
        if not isinstance(zmat_conn, list) or not all(isinstance(row, tuple) and len(row) == 4 for row in zmat_conn):
            raise TypeError("zmat_conn must be a list of tuples of four elements each (symbol, bond, angle, dihedral).")
        if len(zmat) != len(zmat_conn):
            raise ValueError("Length of zmat and zmat_conn must be equal.")
        N = len(zmat)
        if N < 1:
            raise ValueError("Z-matrix must contain at least one atom.")
    
        xyz = np.zeros((N, 3))
        symbols = [row[0] for row in zmat]
    
        xyz[0] = [0.0, 0.0, 0.0]
    
        if N > 1:
            if zmat[1][1] is None:
                raise ValueError("Bond length for the second atom is missing.")
            xyz[1] = [zmat[1][1], 0.0, 0.0]
    
        if N > 2:
            if zmat[2][1] is None or zmat[2][2] is None:
                raise ValueError("Bond length or bond angle for the third atom is missing.")
            bond_length = zmat[2][1]
            bond_angle = np.radians(zmat[2][2])
            ref = zmat_conn[2][1]
            if ref == 0:
                x = bond_length * np.cos(bond_angle)
                y = bond_length * np.sin(bond_angle)
                xyz[2] = [x, y, 0.0]
            elif ref == 1:
                x = zmat[1][1] - bond_length * np.cos(bond_angle)
                y = - bond_length * np.sin(bond_angle)
                xyz[2] = [x, y, 0.0]
            else:
                raise ValueError("Invalid connectivity for the third atom; reference must be 0 or 1.")
    
        if N > 3:
            for i in range(3, N):
                if zmat[i][1] is None or zmat[i][2] is None or zmat[i][3] is None:
                    raise ValueError(f"Internal coordinate(s) for atom {i+1} are missing.")
                bond_length = zmat[i][1]
                bond_angle = np.radians(zmat[i][2])
                dihedral_angle = np.radians(zmat[i][3])
                try:
                    _, j, k, l = zmat_conn[i]
                except Exception:
                    raise ValueError(f"Connectivity for atom {i+1} is invalid.")
                r_j, r_k, r_l, tvec1, tvec2, r_kj, r_kl, tcrp, ncrp = ZmatUtils.form_orthonormal_frame(xyz, j, k, l)
                x = bond_length * np.sin(bond_angle) * np.cos(dihedral_angle)
                y = bond_length * np.sin(bond_angle) * np.sin(dihedral_angle)
                z = bond_length * np.cos(bond_angle)
                local_coords = x * ncrp + y * tcrp - z * tvec1
                xyz[i] = r_j + local_coords
    
        atoms = Atoms(symbols = symbols, positions=xyz)
        return atoms

    @staticmethod
    def get_B_matrix(zmat, zmat_conn):
        """
        Calculate the Wilson B-matrix analytically given a Z-matrix and its connectivities.
        """
        if len(zmat) != len(zmat_conn):
            raise ValueError("Length of zmat and zmat_conn must be equal.")
            
        atoms = ZmatUtils.zmat_2_atoms(zmat, zmat_conn)
        xyz = atoms.get_positions()
        N = len(atoms)
        if N < 3:
            raise ValueError("At least 3 atoms are required to compute the B-matrix.")
        
        B = np.zeros([3 * N - 6, 3 * N])
        B[0, 3] = 1
    
        bond_length = zmat[2][1]
        bond_angle = np.radians(zmat[2][2])
    
        if zmat_conn[2][1] == 0:
            B[1, 6] = np.cos(bond_angle)
            B[2, 6] = - bond_length * np.sin(bond_angle)
            B[1, 7] = np.sin(bond_angle)
            B[2, 7] = bond_length * np.cos(bond_angle)
        elif zmat_conn[2][1] == 1:
            B[0, 6] = 1
            B[1, 6] = - np.cos(bond_angle)
            B[2, 6] = bond_length * np.sin(bond_angle)
            B[1, 7] = - np.sin(bond_angle)
            B[2, 7] = - bond_length * np.cos(bond_angle)
        else:
            raise ValueError("Invalid connectivity for atom 3 in zmat_conn; expected reference index 0 or 1.")
    
        if N > 3:
            for i in range(3, N):
                try:
                    _, j, k, l = zmat_conn[i]
                except Exception:
                    raise ValueError(f"Invalid connectivity for atom {i+1}.")
                
                bond_length = zmat[i][1]
                bond_angle = np.radians(zmat[i][2])
                dihedral_angle = np.radians(zmat[i][3])
                r_j, r_k, r_l, tvec1, tvec2, r_kj, r_kl, tcrp, ncrp = ZmatUtils.form_orthonormal_frame(xyz, j, k, l)
                psi_kl = np.linalg.norm(r_kl)
                psi_kj = np.linalg.norm(r_kj)
                psi_kjxkl = np.linalg.norm(np.cross(tvec1, tvec2))
                for s in range(3 * N - 6):
                    D_j = np.array([B[s, 3 * j], B[s, 3 * j + 1], B[s, 3 * j + 2]])
                    D_k = np.array([B[s, 3 * k], B[s, 3 * k + 1], B[s, 3 * k + 2]])
                    D_l = np.array([B[s, 3 * l], B[s, 3 * l + 1], B[s, 3 * l + 2]])
                    D_kj = D_j - D_k
                    D_kl = D_l - D_k
                    Dpsi_kj = np.dot(tvec1, D_kj)
                    Dpsi_kl = np.dot(tvec2, D_kl)
                    Dtvec1 = psi_kj ** (-2) * (D_kj * psi_kj - Dpsi_kj * r_kj)
                    Dtvec2 = psi_kl ** (-2) * (D_kl * psi_kl - Dpsi_kl * r_kl)
                    Dpsi_kjxkl = np.dot(tcrp, np.cross(Dtvec1, tvec2) + np.cross(tvec1, Dtvec2))
                    Dtcrp = ((np.cross(Dtvec1, tvec2) + np.cross(tvec1, Dtvec2)) - Dpsi_kjxkl * tcrp) * psi_kjxkl ** (-1)
                    Dncrp = np.cross(Dtcrp, tvec1) + np.cross(tcrp, Dtvec1)
                    for c in range(3):
                        B[s, 3 * i + c] = (
                            B[s, 3 * j + c]
                            + Dncrp[c] * bond_length * np.sin(bond_angle) * np.cos(dihedral_angle)
                            + ncrp[c] * ZmatUtils.kronecker_delta(3 * i - 6, s) * np.sin(bond_angle) * np.cos(dihedral_angle)
                            + ncrp[c] * (bond_length * (ZmatUtils.kronecker_delta(3 * i - 5, s) * np.cos(bond_angle) * np.cos(dihedral_angle) - ZmatUtils.kronecker_delta(3 * i - 4, s) * np.sin(bond_angle) * np.sin(dihedral_angle)))
                            + Dtcrp[c] * bond_length * np.sin(bond_angle) * np.sin(dihedral_angle)
                            + tcrp[c] * ZmatUtils.kronecker_delta(3 * i - 6, s) * np.sin(bond_angle) * np.sin(dihedral_angle)
                            + tcrp[c] * (bond_length * (ZmatUtils.kronecker_delta(3 * i - 5, s) * np.cos(bond_angle) * np.sin(dihedral_angle) + ZmatUtils.kronecker_delta(3 * i - 4, s) * np.sin(bond_angle) * np.cos(dihedral_angle)))
                            - Dtvec1[c] * bond_length * np.cos(bond_angle)
                            - tvec1[c] * (ZmatUtils.kronecker_delta(3 * i - 6, s) * np.cos(bond_angle) - bond_length * ZmatUtils.kronecker_delta(3 * i - 5, s) * np.sin(bond_angle))
                        )
        return B


    @staticmethod
    def get_curvature_tensor(zmat, zmat_conn):
        N = len(zmat)
        K = np.zeros([3 * N, 3 * N - 6, 3 * N - 6])
        atoms = ZmatUtils.zmat_2_atoms(zmat, zmat_conn)
        xyz = atoms.get_positions()
        B = ZmatUtils.get_B_matrix(zmat, zmat_conn)
        for i in range(N):
            if i == 0:
                continue
            elif i == 1:
                continue
            elif i == 2:
                bond_length = zmat[2][1]
                bond_angle = np.radians(zmat[2][2])
                if zmat_conn[2][1] == 0:
                    K[6, 1, 2] = -np.sin(bond_angle)
                    K[6, 2, 1] = -np.sin(bond_angle)
                    K[6, 2, 2] = -bond_length * np.cos(bond_angle)
                    K[7, 1, 2] = np.cos(bond_angle)
                    K[7, 2, 1] = np.cos(bond_angle)
                    K[7, 2, 2] = -bond_length * np.sin(bond_angle)
                elif zmat_conn[2][1] == 1:
                    K[6, 1, 2] = np.sin(bond_angle)
                    K[6, 2, 1] = np.sin(bond_angle)
                    K[6, 2, 2] = bond_length * np.cos(bond_angle)
                    K[7, 1, 2] = -np.cos(bond_angle)
                    K[7, 2, 1] = -np.cos(bond_angle)
                    K[7, 2, 2] = bond_length * np.sin(bond_angle)
                else:
                    raise ValueError("Invalid connectivity for atom 3 in zmat_conn; expected reference index 0 or 1.")
            elif N > 3:
                try:
                    _, j, k, l = zmat_conn[i]
                except Exception:
                    raise ValueError(f"Invalid connectivity for atom {i+1}.")
                bond_length = zmat[i][1]
                bond_angle = np.radians(zmat[i][2])
                dihedral_angle = np.radians(zmat[i][3])
                r_j, r_k, r_l, tvec1, tvec2, r_kj, r_kl, tcrp, ncrp = ZmatUtils.form_orthonormal_frame(xyz, j, k, l)
                psi_kl = np.linalg.norm(r_kl)
                psi_kj = np.linalg.norm(r_kj)
                psi_kjxkl = np.linalg.norm(np.cross(tvec1, tvec2))
                for s in range(3 * N - 6):
                    Ds_j = np.array([B[s, 3 * j], B[s, 3 * j + 1], B[s, 3 * j + 2]])
                    Ds_k = np.array([B[s, 3 * k], B[s, 3 * k + 1], B[s, 3 * k + 2]])
                    Ds_l = np.array([B[s, 3 * l], B[s, 3 * l + 1], B[s, 3 * l + 2]])
                    Ds_kj = Ds_j - Ds_k
                    Ds_kl = Ds_l - Ds_k
    
                    Dspsi_kj = np.dot(tvec1, Ds_kj)
                    Dspsi_kl = np.dot(tvec2, Ds_kl)
                    Dstvec1 = psi_kj ** (-2) * (Ds_kj * psi_kj - Dspsi_kj * r_kj)
                    Dstvec2 = psi_kl ** (-2) * (Ds_kl * psi_kl - Dspsi_kl * r_kl)
                    Dspsi_kjxkl = np.dot(tcrp, np.cross(Dstvec1, tvec2) + np.cross(tvec1, Dstvec2))
                    Dstcrp = ((np.cross(Dstvec1, tvec2) + np.cross(tvec1, Dstvec2)) - Dspsi_kjxkl * tcrp) * psi_kjxkl ** (-1)
                    Dsncrp = np.cross(Dstcrp, tvec1) + np.cross(tcrp, Dstvec1)
                    for t in range(s, 3 * N - 6):
                        Dt_j = np.array([B[t, 3 * j], B[t, 3 * j + 1], B[t, 3 * j + 2]])
                        Dt_k = np.array([B[t, 3 * k], B[t, 3 * k + 1], B[t, 3 * k + 2]])
                        Dt_l = np.array([B[t, 3 * l], B[t, 3 * l + 1], B[t, 3 * l + 2]])
                        Dt_kj = Dt_j - Dt_k
                        Dt_kl = Dt_l - Dt_k
    
                        Dtpsi_kj = np.dot(tvec1, Dt_kj)
                        Dtpsi_kl = np.dot(tvec2, Dt_kl)
                        Dttvec1 = psi_kj ** (-2) * (Dt_kj * psi_kj - Dtpsi_kj * r_kj)
                        Dttvec2 = psi_kl ** (-2) * (Dt_kl * psi_kl - Dtpsi_kl * r_kl)
                        Dtpsi_kjxkl = np.dot(tcrp, np.cross(Dttvec1, tvec2) + np.cross(tvec1, Dttvec2))
                        Dttcrp = ((np.cross(Dttvec1, tvec2) + np.cross(tvec1, Dttvec2)) - Dtpsi_kjxkl * tcrp) * psi_kjxkl ** (-1)
                        Dtncrp = np.cross(Dttcrp, tvec1) + np.cross(tcrp, Dttvec1)
    
                        DtDs_j = np.array([K[3 * j, s, t], K[3 * j + 1, s, t], K[3 * j + 2, s, t]])
                        DtDs_k = np.array([K[3 * k, s, t], K[3 * k + 1, s, t], K[3 * k + 2, s, t]])
                        DtDs_l = np.array([K[3 * l, s, t], K[3 * l + 1, s, t], K[3 * l + 2, s, t]])
    
                        DtDs_kj = DtDs_j - DtDs_k
                        DtDs_kl = DtDs_l - DtDs_k
                        
                        DtDspsi_kj = np.dot(Dttvec1, Ds_kj) + np.dot(tvec1, DtDs_kj)
                        DtDspsi_kl = np.dot(Dttvec2, Ds_kl) + np.dot(tvec2, DtDs_kl)
    
                        DtDstvec1 = (
                            ((DtDs_kj * psi_kj + Ds_kj * Dtpsi_kj - DtDspsi_kj * r_kj - Dspsi_kj * Dt_kj) * psi_kj ** 2
                            - (Ds_kj * psi_kj - Dspsi_kj * r_kj) * (2 * psi_kj * Dtpsi_kj)) * psi_kj ** (-4)
                        )
    
                        DtDstvec2 = (
                            ((DtDs_kl * psi_kl + Ds_kl * Dtpsi_kl - DtDspsi_kl * r_kl - Dspsi_kl * Dt_kl) * psi_kl ** 2
                            - (Ds_kl * psi_kl - Dspsi_kl * r_kl) * (2 * psi_kl * Dtpsi_kl)) * psi_kl ** (-4)
                        )
    
                        DtDspsi_kjxkl = (
                            np.dot(Dttcrp, (np.cross(Dstvec1, tvec2) + np.cross(tvec1, Dstvec2)))
                            + np.dot(tcrp, (np.cross(DtDstvec1, tvec2) + np.cross(Dstvec1, Dttvec2) 
                                            + np.cross(Dttvec1, Dstvec2) + np.cross(tvec1, DtDstvec2)))
                        )
    
                        DtDstcrp = (
                            ((np.cross(DtDstvec1, tvec2) + np.cross(Dstvec1,  Dttvec2)
                              + np.cross(Dttvec1,  Dstvec2) + np.cross(tvec1, DtDstvec2)
                              - DtDspsi_kjxkl * tcrp - Dspsi_kjxkl * Dttcrp) * psi_kjxkl
                             - (np.cross(Dstvec1, tvec2) + np.cross(tvec1, Dstvec2)
                                - Dspsi_kjxkl * tcrp) * Dtpsi_kjxkl)
                            * psi_kjxkl**(-2)            # exponent −1  (never −2)
                        )
    
                        DtDsncrp = (
                            np.cross(DtDstcrp, tvec1) + np.cross(Dstcrp, Dttvec1) 
                            + np.cross(Dttcrp, Dstvec1) + np.cross(tcrp, DtDstvec1)
                        )
                    
                        for c in range(3):
                            ij = 3 * i - 6
                            ijk = 3 * i - 5
                            ijkl = 3 * i - 4
                            K[3 * i + c, s, t] = (
                                K[3 * j + c, s, t]
                                + DtDsncrp[c] * (bond_length * np.sin(bond_angle) * np.cos(dihedral_angle))
                                + Dsncrp[c] * (ZmatUtils.kronecker_delta(ij, t) * np.sin(bond_angle) * np.cos(dihedral_angle)
                                            + bond_length * ZmatUtils.kronecker_delta(ijk, t) * np.cos(bond_angle) * np.cos(dihedral_angle)
                                            - bond_length * ZmatUtils.kronecker_delta(ijkl, t) * np.sin(bond_angle) * np.sin(dihedral_angle))
                                + Dtncrp[c] * (ZmatUtils.kronecker_delta(ij, s) * np.sin(bond_angle) * np.cos(dihedral_angle))
                                + ncrp[c] * (ZmatUtils.kronecker_delta(ij, s) * ZmatUtils.kronecker_delta(ijk, t) * np.cos(bond_angle) * np.cos(dihedral_angle)
                                             - ZmatUtils.kronecker_delta(ij, s) * ZmatUtils.kronecker_delta(ijkl, t) * np.sin(bond_angle) * np.sin(dihedral_angle))
                                + (Dtncrp[c] * bond_length + ncrp[c] * ZmatUtils.kronecker_delta(ij, t)) 
                                * (ZmatUtils.kronecker_delta(ijk, s) * np.cos(bond_angle) * np.cos(dihedral_angle)
                                   - ZmatUtils.kronecker_delta(ijkl, s) * np.sin(bond_angle) * np.sin(dihedral_angle))
                                + ncrp[c] * bond_length * (- ZmatUtils.kronecker_delta(ijk, s) * ZmatUtils.kronecker_delta(ijk, t) * np.sin(bond_angle) * np.cos(dihedral_angle)
                                                           - ZmatUtils.kronecker_delta(ijk, s) * ZmatUtils.kronecker_delta(ijkl, t) * np.cos(bond_angle) * np.sin(dihedral_angle)
                                                           - ZmatUtils.kronecker_delta(ijkl, s) * ZmatUtils.kronecker_delta(ijk, t) * np.cos(bond_angle) * np.sin(dihedral_angle)
                                                           - ZmatUtils.kronecker_delta(ijkl, s) * ZmatUtils.kronecker_delta(ijkl, t) * np.sin(bond_angle) * np.cos(dihedral_angle))
                                + DtDstcrp[c] * (bond_length * np.sin(bond_angle) * np.sin(dihedral_angle))
                                + Dstcrp[c] * (ZmatUtils.kronecker_delta(ij, t) * np.sin(bond_angle) * np.sin(dihedral_angle) 
                                               + bond_length * ZmatUtils.kronecker_delta(ijk, t) * np.cos(bond_angle) * np.sin(dihedral_angle) 
                                               + bond_length * ZmatUtils.kronecker_delta(ijkl, t) * np.sin(bond_angle) * np.cos(dihedral_angle))
                                + tcrp[c] * (ZmatUtils.kronecker_delta(ij, s) * ZmatUtils.kronecker_delta(ijk, t) * np.cos(bond_angle) * np.sin(dihedral_angle) 
                                             + ZmatUtils.kronecker_delta(ij, s) * ZmatUtils.kronecker_delta(ijkl, t) * np.sin(bond_angle) * np.cos(dihedral_angle))
                                + Dttcrp[c] * (ZmatUtils.kronecker_delta(ij, s) * np.sin(bond_angle) * np.cos(dihedral_angle))
                                + (Dttcrp[c] * bond_length + tcrp[c] * ZmatUtils.kronecker_delta(ij, t))
                                * (ZmatUtils.kronecker_delta(ijk, s) * np.cos(bond_angle) * np.sin(dihedral_angle) 
                                   + ZmatUtils.kronecker_delta(ijkl, s) * np.sin(bond_angle) * np.cos(dihedral_angle))
                                + tcrp[c] * bond_length * (- ZmatUtils.kronecker_delta(ijk, s) * ZmatUtils.kronecker_delta(ijk, t) * np.sin(bond_angle) * np.sin(dihedral_angle) 
                                                           + ZmatUtils.kronecker_delta(ijk, s) * ZmatUtils.kronecker_delta(ijkl, t) * np.cos(bond_angle) * np.cos(dihedral_angle) 
                                                           + ZmatUtils.kronecker_delta(ijkl, s) * ZmatUtils.kronecker_delta(ijk, t) * np.cos(bond_angle) * np.cos(dihedral_angle) 
                                                           - ZmatUtils.kronecker_delta(ijkl, s) * ZmatUtils.kronecker_delta(ijkl, t) * np.sin(bond_angle) * np.sin(dihedral_angle))
                                - DtDstvec1[c] * bond_length * np.cos(bond_angle)
                                - Dstvec1[c] * (ZmatUtils.kronecker_delta(ij, t) * np.cos(bond_angle) - bond_length * ZmatUtils.kronecker_delta(ijk, t) * np.sin(bond_angle))
                                - Dttvec1[c] * (ZmatUtils.kronecker_delta(ij, s) * np.cos(bond_angle) - bond_length * ZmatUtils.kronecker_delta(ijk, s) * np.sin(bond_angle))
                                - tvec1[c] * (- ZmatUtils.kronecker_delta(ij, s) * ZmatUtils.kronecker_delta(ijk, t) * np.sin(bond_angle) 
                                              - ZmatUtils.kronecker_delta(ij, t) * ZmatUtils.kronecker_delta(ijk, s) * np.sin(bond_angle) 
                                              - bond_length * ZmatUtils.kronecker_delta(ijk, s) * ZmatUtils.kronecker_delta(ijk, t) * np.cos(bond_angle))
                            )
    
                            K[3 * i + c, t, s] = K[3 * i + c, s, t]
        #K[np.abs(K) < 1e-9] = 0                
        return K     
                    

    @staticmethod
    def get_single_fd_grad(zmat, zmat_conn, q_i, q_j, r_i, r_j, delta):
        """
        Calculate the gradient dr/dq via the central difference method.
        """
        if delta == 0:
            raise ValueError("delta must be non-zero.")
        if q_i < 0 or q_i >= len(zmat):
            raise IndexError("q_i is out of range for the zmat.")
        if q_j not in [1, 2, 3]:
            raise ValueError("q_j must be 1 (bond), 2 (angle) or 3 (dihedral).")
        if r_i < 0 or r_i >= len(zmat):
            raise IndexError("r_i is out of range for the zmat.")
        if r_j not in [0, 1, 2]:
            raise ValueError("r_j must be 0 (x), 1 (y) or 2 (z).")
    
        zmat_fwd = copy.deepcopy(zmat)
        zmat_fwd[q_i][q_j] = zmat[q_i][q_j] + delta
        atoms_fwd = ZmatUtils.zmat_2_atoms(zmat_fwd, zmat_conn)
        try:
            r_fwd = atoms_fwd[r_i].position[r_j]
        except IndexError:
            raise IndexError("r_i is out of range in the forward-perturbed atoms object.")
    
        zmat_bwd = copy.deepcopy(zmat)
        zmat_bwd[q_i][q_j] = zmat[q_i][q_j] - delta
        atoms_bwd = ZmatUtils.zmat_2_atoms(zmat_bwd, zmat_conn)
        try:
            r_bwd = atoms_bwd[r_i].position[r_j]
        except IndexError:
            raise IndexError("r_i is out of range in the backward-perturbed atoms object.")
    
        fd_grad = (r_fwd - r_bwd) / (2 * delta)
        return fd_grad

    @staticmethod
    def get_fd_B_matrix(zmat, zmat_conn, db, da, dt):
        """
        Calculate the Wilson B-matrix via finite difference given a Z-matrix and its connectivities.
        """
        if db == 0 or da == 0 or dt == 0:
            raise ValueError("Finite difference step sizes db, da, and dt must all be non-zero.")
        if len(zmat) == 0:
            raise ValueError("zmat cannot be empty.")
        if len(zmat) != len(zmat_conn):
            raise ValueError("Length of zmat and zmat_conn must be equal.")
    
        deltas = [db, da, dt]
        N = len(zmat)
        B = np.zeros((3 * N - 6, 3 * N), dtype=float)
        row_cnt = 0
    
        for q_i, row in enumerate(zmat):
            for q_j in range(1, 4):
                if row[q_j] is None:
                    continue
                col_cnt = 0
                for r_i in range(N):
                    for r_j in range(3):
                        grad = ZmatUtils.get_single_fd_grad(zmat, zmat_conn, q_i, q_j, r_i, r_j, deltas[q_j - 1])
                        B[row_cnt, col_cnt] = grad
                        col_cnt += 1
                row_cnt += 1
        return B

    
    @staticmethod
    def _displace(zmat, atom, kind, delta):
        """Return a copy of the Z-matrix with q(atom,kind) shifted by ±delta."""
        z = copy.deepcopy(zmat)
        z[atom][kind] += delta
        return z
    

    @staticmethod
    def get_fd_curvature_tensor(zmat, zmat_conn, db, da, dt):
        """
        K[i, s, t] = ∂²r_i / ∂q_s ∂q_t   (shape 3N × M × M) using
        finite differences of the B-matrix.
        """
        # -----------------------------------------------------------------
        # 1) internal-coordinate bookkeeping
        # -----------------------------------------------------------------
        valid   = [(i, j) for i, row in enumerate(zmat)
                            for j in range(1, len(row)) if row[j] is not None]
        M       = len(valid)
        idx_of  = {k: m for m, k in enumerate(valid)}   # (atom,kind) → 0…M−1
    
        deltas  = [db, da, dt]                          # step sizes
        scale   = np.array([1.0 if j == 1 else 180.0 / np.pi  # factor per column
                            for (_, j) in valid])
    
        atoms   = ZmatUtils.zmat_2_atoms(zmat, zmat_conn)
        n_cart  = 3 * len(atoms)
        K       = np.zeros((n_cart, M, M))
    
        # -----------------------------------------------------------------
        # 2) iterate over “second-derivative” index t (columns)
        # -----------------------------------------------------------------
        for t, (atom_t, kind_t) in enumerate(valid):
    
            delta_t = deltas[kind_t - 1]
    
            # B(q_t + delta) and B(q_t − delta)
            bp = ZmatUtils.get_B_matrix(ZmatUtils._displace(zmat, atom_t, kind_t, + delta_t),
                                        zmat_conn)
            bm = ZmatUtils.get_B_matrix(ZmatUtils._displace(zmat, atom_t, kind_t, - delta_t),
                                        zmat_conn)
    
            # central finite difference dB/dq_t
            dB = (bp - bm) / (2.0 * delta_t)            # shape (M, 3N)
            if kind_t in (2, 3):                        # angle or torsion column
                dB *= 180.0 / np.pi
    
            # -----------------------------------------------------------------
            # 3) write the whole column into the tensor and enforce symmetry
            # -----------------------------------------------------------------
            K[:, :, t] = dB.T                           # (3N, M) → tensor col
            K[:, t, :] = dB.T                           # mirror to keep K symmetric
    
        return K

    @staticmethod
    def kabsch(P, Q):
        """
        Compute the optimal rotation matrix to align P to Q using the Kabsch algorithm.
    
        Parameters:
            P, Q : np.ndarray of shape (N, 3)
                The coordinates of N atoms in each structure (assumed ordered consistently).
    
        Returns:
            R : np.ndarray of shape (3, 3)
                The rotation matrix.
            P_com : np.ndarray
                Center-of-mass of P (arithmetic mean).
            Q_com : np.ndarray
                Center-of-mass of Q (arithmetic mean).
        """
        # Compute centers (using arithmetic mean here; for mass-weighted, use atoms.get_center_of_mass())
        P_com = P.mean(axis=0)
        Q_com = Q.mean(axis=0)
        P_centered = P - P_com
        Q_centered = Q - Q_com
    
        # Compute covariance matrix
        C = np.dot(P_centered.T, Q_centered)
        
        # SVD of the covariance matrix
        U, S, Vt = np.linalg.svd(C)
        
        # Ensure a right-handed coordinate system
        d = np.linalg.det(np.dot(U, Vt))
        if d < 0:
            U[:, -1] *= -1
    
        R = np.dot(U, Vt)
        return R, P_com, Q_com

    @staticmethod
    def calculate_rmsd(atoms1, atoms2):
        """
        Calculate the RMSD between two ASE Atoms objects after optimal alignment.
        
        The structures are first aligned by subtracting their centers of mass,
        then rotated using the optimal rotation (via Kabsch algorithm) to minimize RMSD.
        
        Parameters:
            atoms1, atoms2 : ase.Atoms
                The two molecular structures to compare.
        
        Returns:
            rmsd : float
                The root-mean-square deviation between the aligned structures.
        """
        # Extract positions from ASE Atoms objects
        pos1 = atoms1.get_positions()
        pos2 = atoms2.get_positions()
        
        # Ensure both structures have the same number of atoms
        if pos1.shape != pos2.shape:
            raise ValueError("Both Atoms objects must have the same number of atoms.")
        
        # Get optimal rotation matrix and center-of-mass values
        R, com1, com2 = ZmatUtils.kabsch(pos1, pos2)
        
        # Align atoms1 to atoms2:
        pos1_aligned = np.dot(pos1 - com1, R) + com2
        
        # Calculate RMSD
        diff = pos1_aligned - pos2
        rmsd = np.sqrt(np.sum(diff**2) / pos1.shape[0])
        return rmsd

    @staticmethod
    def calculate_rmsd_zmat(zmat1, zmat2, zmat_conn):
        if not (len(zmat1) == len(zmat2)):
            raise ValueError("Shape mismatch between input molecules.")
        elif not (len(zmat1) == len(zmat_conn)):
            raise ValueError("Shape mismatch between molecule 1 and connectivity.")
        elif not (len(zmat2) == len(zmat_conn)):
            raise ValueError("Shape mismatch between molecule 2 and connectivity.")

        atoms1 = ZmatUtils.zmat_2_atoms(zmat1, zmat_conn)
        atoms2 = ZmatUtils.zmat_2_atoms(zmat2, zmat_conn)

        return calculate_rmsd(atoms1, atoms2)

class PrintUtils:
    @staticmethod
    def print_xyz(atoms, comment = '', fmt = '%22.15f', filename = None):
        comment = comment.rstrip()
        if '\n' in comment:
            raise ValueError('Comment line should not have line breaks.')
        natoms = len(atoms)
        print(f'{natoms}')
        print(comment)
        counter_dict = {}
        for s, (x, y, z) in zip(atoms.symbols, atoms.positions):
            if s not in counter_dict:
                counter_dict[s] = 1
            else:
                counter_dict[s] += 1
            s_counted = s + str(counter_dict[s])
            print('%-2s %s %s %s' % (s_counted, fmt % x, fmt % y, fmt % z))

    @staticmethod
    def print_zmat(zmat, zmat_conn, constraints = None):

        # If no constraints are provided, set to an object with empty lists.
        if constraints is None:
            class DummyConstraints:
                def __init__(self):
                    self.bonds = []
                    self.angles = []
                    self.dihedrals = []
            constraints = DummyConstraints()
            
        # Here, each zmat_conn entry is a 4-tuple: (symbol, bond_ref, angle_ref, dihedral_ref)
        for i, (zmat_row, conn_row) in enumerate(zip(zmat, zmat_conn)):
            symbol = zmat_row[0]
            # Extract connectivity indices from the new tuple: skip the first element (symbol)
            c1 = conn_row[1] + 1 if conn_row[1] is not None else ''
            c2 = conn_row[2] + 1 if conn_row[2] is not None else ''
            c3 = conn_row[3] + 1 if conn_row[3] is not None else ''
            if i == 0:
                print(f"{symbol}")
            elif i == 1:
                print(f"{symbol}    {c1}    bnd{i + 1}")
            elif i == 2:
                print(f"{symbol}    {c1}    bnd{i + 1}    {c2}    ang{i + 1}")
            else:
                print(f"{symbol}    {c1}    bnd{i + 1}    {c2}    ang{i + 1}    {c3}    dih{i + 1}")
        print("Variables:")
        # For each atom (from index 1 onward), print the DOFs that are not constrained.
        for i in range(1, len(zmat)):
            atom = zmat[i]
            if not any(idx == i for idx, _ in constraints.bonds):
                if atom[1] is not None:
                    print(f"bnd{i+1}     {atom[1]:.6f}")
            if i >= 2 and not any(idx == i for idx, _ in constraints.angles):
                if atom[2] is not None:
                    print(f"ang{i+1}     {atom[2]:.6f}")
            if i >= 3 and not any(idx == i for idx, _ in constraints.dihedrals):
                if atom[3] is not None:
                    dih = atom[3]
                    if dih > 180:
                        dih = dih - 360
                    print(f"dih{i+1}     {dih:.6f}")
        if constraints.bonds or constraints.angles or constraints.dihedrals:
            print("Constants:")
            for idx, val in constraints.bonds:
                cur_val = val if val is not None else zmat[idx][1]
                print(f"bnd{idx+1}     {cur_val:.6f}")
            for idx, val in constraints.angles:
                cur_val = val if val is not None else zmat[idx][2]
                print(f"ang{idx+1}     {cur_val:.6f}")
            for idx, val in constraints.dihedrals:
                cur_val = val if val is not None else zmat[idx][3]
                if cur_val > 180:
                    cur_val = cur_val - 360
                print(f"dih{idx+1}     {cur_val:.6f}")

    @staticmethod
    def print_forces(forces, zmat, fmt='%22.15f'):
        blank = ' ' * 22
        counter_dict = {}
        for i, row in enumerate(zmat):
            s = row[0]
            if s not in counter_dict:
                counter_dict[s] = 1
            else:
                counter_dict[s] += 1
            s_counted = s + str(counter_dict[s])
            
            if i == 0:
                print('%-2s %s %s %s' % (s_counted, blank, blank, blank))
            elif i == 1:
                print('%-2s %s %s %s' % (s_counted, fmt % forces[0], blank, blank))
            elif i == 2:
                print('%-2s %s %s %s' % (s_counted, fmt % forces[1], fmt % forces[2], blank))
            else:
                force_bond = forces[3 * i - 6]
                force_angle = forces[3 * i - 5]
                force_torsion = forces[3 * i - 4]
                print('%-2s %s %s %s' % (s_counted, fmt % force_bond, fmt % force_angle, fmt % force_torsion))




class ZMatrix:

    def __init__(self, zmat, zmat_conn, model_size, constraints = None, name = None, gpu = False):
        self.name = name if name else "unnamed molecule"
        self.zmat = zmat
        self.zmat_conn = zmat_conn  # Each connectivity is now (symbol, bond, angle, dihedral)
        self.constraints = constraints if constraints else Constraints()  # Default to empty constraints
        if model_size not in ['small', 'medium', 'large']:
            raise ValueError("Model size must be one of 'small', 'medium', or 'large'")
        self.model_size = model_size
        if gpu == True:
            self.calculator = mace_off(model=self.model_size, device='cuda')
        else:
            self.calculator = mace_off(model=self.model_size)

        # Create a dictionary mapping global DOF indices to constraint values.
        # If a constraint's value is None, use the current zmat value.
        self.con_dict = self._find_constraint_values()
        self.con_ids = list(self.con_dict.keys())
        self._apply_constraints()
        self.var_ids = self._find_var_ids()  # Find variable indices
        self.var_list = self._extract_variables()  # Extract initial variables
        self.b_matrix = self._get_B_matrix()
        self.ase_constraints = self._get_ase_constraints()
        
        self.iteration = 0

    def __repr__(self):
        return f"ZMatrix({len(self.zmat_conn)} atoms, {self.constraints})"



    def _find_constraint_values(self):
        con_dict = {}
        # Bonds: global index = index * 3
        for index, val in self.constraints.bonds:
            global_index = index * 3
            if val is None:
                val = self._get_value_by_index(global_index)
            con_dict[global_index] = val
        # Angles: global index = index * 3 + 1
        for index, val in self.constraints.angles:
            global_index = index * 3 + 1
            if val is None:
                val = self._get_value_by_index(global_index)
            con_dict[global_index] = val
        # Dihedrals: global index = index * 3 + 2
        for index, val in self.constraints.dihedrals:
            global_index = index * 3 + 2
            if val is None:
                val = self._get_value_by_index(global_index)
            con_dict[global_index] = val
        return con_dict

    def _apply_constraints(self):
        for global_index, value in self.con_dict.items():
            atom_index = global_index // 3
            coord_index = (global_index % 3) + 1
            self.zmat[atom_index][coord_index] = value

    def _find_var_ids(self):
        total_vars = 3 * len(self.zmat)
        var_ids = [i for i in range(total_vars) if i not in self.con_ids and self._get_value_by_index(i) is not None]
        return var_ids

    def _get_value_by_index(self, index):
        atom_idx = index // 3
        coord_idx = index % 3
        return self.zmat[atom_idx][coord_idx + 1]

    def _extract_variables(self):
        all_values = [coord for row in self.zmat for coord in row[1:]]
        all_values = np.array(all_values)
        return all_values[self.var_ids]

    def _reconstruct_full_z_matrix(self, vars):
        full_values = np.array([coord for row in self.zmat for coord in row[1:]])
        var_id = 0
        for i in range(len(full_values)):
            if i in self.var_ids:
                full_values[i] = vars[var_id]
                var_id += 1
            elif i in self.con_ids:
                full_values[i] = self.con_dict[i]
        reconstructed_zmat = []
        for i, (atom, bond, angle, dihedral) in enumerate(self.zmat):
            bond_val, angle_val, dihedral_val = full_values[i * 3:(i + 1) * 3]
            new_values = [
                bond_val if bond is not None else None,
                angle_val if angle is not None else None,
                dihedral_val if dihedral is not None else None
            ]
            reconstructed_zmat.append((atom, *new_values))
        return reconstructed_zmat

    def _get_B_matrix(self):
        B = ZmatUtils.get_B_matrix(self.zmat, self.zmat_conn)
        return B

    def _get_K_tensor(self):
        K = ZmatUtils.get_curvature_tensor(self.zmat, self.zmat_conn)
        return K

    def _get_ase_constraints(self):
        # Build ASE constraints using the provided (or default) values.
        bonds = []
        for index, val in self.constraints.bonds:
            bond_length = val if val is not None else self.zmat[index][1]
            # For bonds, use connectivity index from zmat_conn: (symbol, bond, angle, dihedral)
            j = self.zmat_conn[index][1]
            bond = [bond_length, [index, j]]
            bonds.append(bond)
        angles = []
        for index, val in self.constraints.angles:
            bond_angle = val if val is not None else self.zmat[index][2]
            j = self.zmat_conn[index][1]
            k = self.zmat_conn[index][2]
            angle = [bond_angle, [index, j, k]]
            angles.append(angle)
        dihedrals = []
        for index, val in self.constraints.dihedrals:
            dihedral_angle = val if val is not None else self.zmat[index][3]
            j = self.zmat_conn[index][1]
            k = self.zmat_conn[index][2]
            l = self.zmat_conn[index][3]
            dihedral = [dihedral_angle, [index, j, k, l]]
            dihedrals.append(dihedral)
        kwargs = {}
        if bonds:
            kwargs["bond"] = bonds
        if angles:
            kwargs["angle"] = angles
        if dihedrals:
            kwargs["dihedrals_deg"] = dihedrals
        c = FixInternals(**kwargs)
        return c

    def get_atoms(self):
        return ZmatUtils.zmat_2_atoms(self.zmat, self.zmat_conn)

    def get_energy(self, vars):
        zmat = self._reconstruct_full_z_matrix(vars)
        atoms = ZmatUtils.zmat_2_atoms(zmat, self.zmat_conn)
        atoms.calc = self.calculator
        energy = atoms.get_potential_energy()
        self.iteration += 1
        print('Iteration', self.iteration)
        PrintUtils.print_xyz(atoms, comment='', fmt='%22.15f')
        print(energy)
        return energy

    def get_forces(self):
        atoms = ZmatUtils.zmat_2_atoms(self.zmat, self.zmat_conn)
        atoms.calc = self.calculator
        forces_cart_2d = atoms.get_forces(apply_constraint=False)
        forces_cart = np.array(forces_cart_2d).reshape(-1, 1)
        B_full = ZmatUtils.get_B_matrix(self.zmat, self.zmat_conn)
        if self.con_ids:
            B_reduced = np.delete(B_full, self.con_ids, axis=0)
        else:
            B_reduced = B_full
        forces = (B_reduced @ forces_cart).flatten()
        return forces

    def get_forces_cart(self):
        atoms = ZmatUtils.zmat_2_atoms(self.zmat, self.zmat_conn)
        atoms.calc = self.calculator
        forces_cart_2d = atoms.get_forces(apply_constraint=False)
        forces_cart = np.array(forces_cart_2d).reshape(-1)
        return forces_cart

    @staticmethod
    def _get_temp_forces(zmat, zmat_conn, calculator):
        atoms = ZmatUtils.zmat_2_atoms(zmat, zmat_conn)
        atoms.calc = calculator
        forces_cart_2d = atoms.get_forces(apply_constraint=False)
        forces_cart = np.array(forces_cart_2d).reshape(-1, 1)
        B = ZmatUtils.get_B_matrix(zmat, zmat_conn)
        forces = (B @ forces_cart).flatten()
        return forces

    def get_jacobian(self, vars):
        zmat = self._reconstruct_full_z_matrix(vars)
        atoms = ZmatUtils.zmat_2_atoms(zmat, self.zmat_conn)
        atoms.calc = self.calculator
        forces_cart_2d = atoms.get_forces(apply_constraint=False)
        forces_cart = np.array(forces_cart_2d).reshape(-1, 1)
        B_full = ZmatUtils.get_B_matrix(zmat, self.zmat_conn)
        if self.con_ids:
            B_reduced = np.delete(B_full, self.con_ids, axis=0)
        else:
            B_reduced = B_full
        forces = (B_reduced @ forces_cart).flatten()
        jacobian = -1 * forces
        for i, element in enumerate(jacobian):
            if i == 2:
                element *= np.pi/180
        return jacobian

    def get_hess_cart(self):
        H_cart = self.calculator.get_hessian(atoms = self.get_atoms())
        N = H_cart.shape[1]
        return H_cart.reshape((3*N, 3*N))
    
    
    def _hessian_column(self, idx, delta, valid_indices):
        """
        Central difference of *forces* with an explicit sign-flip so that
        H =  ∂²E / ∂qₖ ∂qⱼ
        """
        i, j = valid_indices[idx]
    
        # +δ -------------------------------------------------------------
        z_plus       = copy.deepcopy(self.zmat)
        z_plus[i][j] += delta
        F_plus       = self._get_temp_forces(z_plus, self.zmat_conn, self.calculator)
    
        # −δ -------------------------------------------------------------
        z_minus       = copy.deepcopy(self.zmat)
        z_minus[i][j] -= delta
        F_minus       = self._get_temp_forces(z_minus, self.zmat_conn, self.calculator)
    
        #   F = −∂E/∂q    ⇒   dF/dq   =  −∂²E/∂q²
        # so we have to invert the sign once:
        col = -(F_plus - F_minus) / (2.0 * delta)          #  <-- sign fixed   (NEW)
    
        # if *this* coordinate qⱼ is an angle or torsion, rescale the whole column
        if j in (2, 3):                                    # 1 = bond, 2 = angle, 3 = torsion
            col *= 180 / np.pi                            #  <-- unit fix     (NEW)
    
        return col
    
    
    def get_full_fd_hessian(self, db, da, dt):
        """
        Symmetric (3N-6) × (3N-6) Hessian obtained from analytic forces,
        computed serially.
        """
        deltas = [db, da, dt]
    
        # list of internal-coordinate positions (i, j) that are not None
        valid_indices = [(i, j)
                         for i, row in enumerate(self.zmat)
                         for j in range(1, len(row))
                         if row[j] is not None]
    
        M  = len(valid_indices)
        H  = np.empty((M, M))
    
        # --- build each column in a simple Python loop -------------------
        for k in range(M):
            delta = deltas[valid_indices[k][1] - 1]
            H[:, k] = self._hessian_column(k, delta, valid_indices)
    
        # enforce exact symmetry
        #H = 0.5 * (H + H.T)
    
        # copy already-scaled angle/torsion columns into their mirror rows
        for k, (_, j) in enumerate(valid_indices):
            if j in (2, 3):                # angle or torsion
                H[k, :] = H[:, k]
    
        return H
        

    def get_geom_fd_hessian(self, db, da, dt):
        H_cart = self.get_hess_cart()
        B = self._get_B_matrix()
        K = ZmatUtils.get_fd_curvature_tensor(self.zmat, self.zmat_conn, db, da, dt)

        F_cart = self.get_forces_cart()

        H_min = B @ H_cart @ np.transpose(B)
        H_res = -1 * np.einsum('isp,i->sp', K, F_cart)
        return H_min + H_res
    
    def get_hessian(self):
        H_cart = self.get_hess_cart()
        B = self._get_B_matrix()
        K = self._get_K_tensor()
        F_cart = self.get_forces_cart()

        H_min = B @ H_cart @ np.transpose(B)
        H_res = -1 * np.einsum('isp,i->sp', K, F_cart)
        return H_min + H_res

    def callback(self, vars):
        self.iteration += 1
        zmat = self._reconstruct_full_z_matrix(vars)
        atoms = self.get_atoms()
        print("Iteration:", self.iteration, "Current Z-matrix:", zmat, flush=True)
        PrintUtils.print_xyz(atoms, comment=self.name + str(self.iteration), fmt='%22.15f')

    def optimise(self):
        result = minimize(
            self.get_energy,
            self.var_list,
            method='BFGS',
            jac=self.get_jacobian,
            callback=self.callback,
            options={'gtol': 1e-8}
        )
        self.zmat = self._reconstruct_full_z_matrix(result.x)
        self.b_matrix = self._get_B_matrix()  # Update B-matrix
        self.con_dict = self._find_constraint_values()  # Update constraint values
        self.con_ids = list(self.con_dict.keys())
        self.var_ids = self._find_var_ids()  # Update variable indices
        self.var_list = self._extract_variables()  # Extract new variables
        return self.zmat, result.fun
    
    def optimise_ase(self, trajectory = None, mode = 'linesearch'):
        print('Initialising minimisation routine')
        start_tot = time.perf_counter()
        print('Model used:', self.calculator, self.model_size)
        print('Input Z-matrix:')
        print('======================================================================================')
        PrintUtils.print_zmat(self.zmat, self.zmat_conn, self.constraints)
        print('======================================================================================')
        print('Building cartesian molecule from input geometry...')
        atoms = self.get_atoms()
        print('======================================================================================')
        PrintUtils.print_xyz(atoms, comment='Input coordinates of ' + self.name, fmt='%22.15f')
        print('======================================================================================')
        atoms.calc = self.calculator
        del atoms.constraints
        
        atoms.set_constraint([self.ase_constraints])

        if mode == 'linesearch':
            dyn = BFGSLineSearch(atoms, trajectory = trajectory, restart = f'{self.name}_opt.json')
            print('Now beginning ASE BFGS Line Search minimisation routine')
            print('--------------------------------------------------------------------------------------')
            start_min = time.perf_counter()
            dyn.run(fmax=1e-8)
            end_min = time.perf_counter()
            energy = atoms.get_potential_energy()
            print('--------------------------------------------------------------------------------------')
            print('! ASE minimisation complete. U_tot =', energy * 0.0367493, 'Ha, or', energy, 'eV')
            print('--------------------------------------------------------------------------------------')

        elif mode == 'bfgs':
            dyn = BFGS(atoms, trajectory = trajectory, restart = f'{self.name}_opt.json')
            print('Now beginning ASE BFGS minimisation routine')
            print('--------------------------------------------------------------------------------------')
            start_min = time.perf_counter()
            dyn.run(fmax=1e-8)
            end_min = time.perf_counter()
            energy = atoms.get_potential_energy()
            print('--------------------------------------------------------------------------------------')
            print('! ASE minimisation complete. U_tot =', energy * 0.0367493, 'Ha, or', energy, 'eV')
            print('--------------------------------------------------------------------------------------')

        zmat_minimised = ZmatUtils.atoms_2_zmat(atoms, self.zmat_conn)
        atoms_minimised = ZmatUtils.zmat_2_atoms(zmat_minimised, self.zmat_conn)
        atoms_minimised.calc = self.calculator
        
        forces_cart_2d = atoms_minimised.get_forces(apply_constraint=False)
        forces_cart = np.array(forces_cart_2d).reshape(-1, 1)
        self.zmat = zmat_minimised
        print('Optimised Z-matrix:')
        print('======================================================================================')
        PrintUtils.print_zmat(self.zmat, self.zmat_conn, self.constraints)
        print('======================================================================================')
        self.b_matrix = self._get_B_matrix()  # Update B-matrix
        forces = (self.b_matrix @ forces_cart).flatten()

        self.var_list = self._extract_variables()  # Extract new variables

        print('Optimised cartesian coordinates:')        
        print('======================================================================================')
        PrintUtils.print_xyz(atoms_minimised, comment='ASE minimised ' + self.name, fmt='%22.15f')
        print('======================================================================================')
        print('Forces in terms of dU/db [Ha/bohr], dU/da [Ha/rad], and dU/dt [Ha/rad]:')
        print('======================================================================================')
        PrintUtils.print_forces(forces, self.zmat)
        print('======================================================================================')
        print('Routine finished successfully.')

        end_tot = time.perf_counter()
        wall_tot = end_tot - start_tot
        wall_min = end_min - start_min
        
        print(f'Total wall time = {wall_tot:.6f} seconds')
        print(f'Minimisation wall time = {wall_min:.6f} seconds')
        return zmat_minimised, energy, forces
